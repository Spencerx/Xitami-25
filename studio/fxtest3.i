/*---------------------------------------------------------------------------*
 *  fxtest3.i - LIBERO dialog interpreter for fxtest3.c.                     *
 *  Generated by LIBERO 2.4 on 22 Jul, 2004, 16:52.                          *
 *---------------------------------------------------------------------------*/

    memset (parent_args, 0, 2048);
    memset (child_args, 0, 2048);
    _LR_call_wanted = FALSE;            /*  Initialise general variables     */

    if (_LR_load_context () == 0)       /*  If no context, initialise        */
      {
        ctx._LR_state = 0;              /*  First state is always 0          */
        /*  Get arguments from calling program                               */
        CONTEXT_GETG ("_args", parent_args, 2048);

        /*  Create initial form and initialise it for this session           */
        session-> form = form_init (&form_fxtest3, TRUE);
        if (session-> form == NULL)
            return (FEEDBACK_ERROR);
        form_data = (FXTEST3_DATA *) session-> form-> data;
        session-> form-> click_event = enter_event;
        if (streq (SYMVAL ("SERVER_SECURITY"), "SSL"))
            session-> form-> ssl_protocol = 1;
        else
            session-> form-> ssl_protocol = 0;

        /*  Get initial finite-state event from the program                  */
        the_next_event = _LR_null_event;
        initialise_the_program ();
      }
    else
      {
        /*  We have context: continue from call-program or show-form         */
        form_data = (FXTEST3_DATA *) session-> form-> data;
        if (the_next_event == _LR_show_event)
          {
            /*  Get form - if there are invalid dates or numbers, reshow     */
            form_changes = form_get (session-> form,
                                       (char *) session-> buffer_-> data);
            if (form_changes == -1)
              {
                fxput_text (FXTEST3_MESSAGE_TO_USER, form_strerror);
                _LR_show_the_form (TRUE);
                return (FEEDBACK_SHOW);
              }
            else
                fxput_text (FXTEST3_MESSAGE_TO_USER, "");

            after_showing_form ();
            get_form_event ();

            /*  If the form could not generate an event, get one             */
            if (the_next_event == _LR_null_event)
                the_next_event = enter_event;
          }
        else
        if (the_next_event == _LR_call_event)
          {
            if (session-> program_callcode == CALLCODE_OKAY)
              {
                /*  Get return arguments from called program                 */
                CONTEXT_GETG ("_args", child_args, 2048);
                after_return_call ();
              }
            else
                call_request_failed ();
          }
      }
    while (the_next_event != terminate_event)
      {
        /*  After a call, restore the event and do the next dialog step      */
        if (the_next_event == _LR_call_event)
            the_next_event = ctx._LR_saved_event;
        else
            if (_LR_enter_state ())
                break;

        form_use (session-> form);
        /*  Execute module list                                              */
        FOREVER
          {
            if (exception_raised || _LR_call_wanted)
                break;
            _LR_vecptr = &_LR_vector [ctx._LR_index][ctx._LR_modnbr];
            if (*_LR_vecptr == _LR_STOP)
                break;
            else
                ctx._LR_modnbr++;
            (*_LR_module [*_LR_vecptr]) ();
          }
        if (_LR_call_wanted)
          {
            ctx._LR_saved_event = the_next_event;
            the_next_event = _LR_call_event;
            _LR_save_context ();
            CONTEXT_PUTG ("_args", child_args, 2048);
            return (FEEDBACK_CALL);
          }
        else
        if (exception_raised)
          {
            if (the_exception_event != _LR_null_event)
                ctx._LR_event = the_exception_event;
            the_next_event = ctx._LR_event;
          }
        else
            ctx._LR_state = _LR_nextst [ctx._LR_state][ctx._LR_event];

        /*  If no event supplied, format and show form                       */
        if (the_next_event == _LR_null_event)
          {
            _LR_show_the_form (FALSE);
            return (FEEDBACK_SHOW);
          }
      }
    form_term (session-> form);
    CONTEXT_PUTG ("_args", parent_args, 2048);
    return (FEEDBACK_RETURN);           /*  Normal end of program            */
}

/*- Private dialog routines -------------------------------------------------*/

static int
_LR_enter_state (void)
{
    ctx._LR_event = the_next_event;
    if (the_next_event == _LR_null_event)
      {
        coprintf ("fxtest3: No event set after event %d in state %d",
                             ctx._LR_event, ctx._LR_state);
        return (1);                     /*  End dialog program               */
      }
    else
    if (ctx._LR_event >= 5 || ctx._LR_event < 0)
      {
        coprintf ("fxtest3: State %d - event %d is out of range",
                         ctx._LR_state, ctx._LR_event);
        return (1);                     /*  End dialog program               */
      }
    ctx._LR_saved_state = ctx._LR_state;
    ctx._LR_index = _LR_action [ctx._LR_state][ctx._LR_event];
    if (ctx._LR_index == 0)
      {
        coprintf ("fxtest3: State %d - event %d is not accepted",
                         ctx._LR_state, ctx._LR_event);
        return (1);                     /*  End dialog program               */
      }
    the_next_event          = _LR_null_event;
    the_exception_event     = _LR_null_event;
    exception_raised        = FALSE;
    ctx._LR_modnbr = 0;                 /*  Start event vector at start      */
    return (0);                         /*  End dialog program               */
}

static int
_LR_load_context (void)
{
    FORM_ITEM
        *form;                          /*  Newly-allocated form item        */
    byte
        *data;                          /*  Allocated form data              */

    /*  Load dialog and programmer context blocks                            */
    if (!context_get (SCOPE_LOCAL, "_ctx", &ctx, sizeof (ctx)))
        return (0);                     /*  Context not found                */
    context_get (SCOPE_LOCAL, "_blk", &cb, sizeof (cb));
    context_get (SCOPE_LOCAL, "_pargs", parent_args, 2048);
    context_get (SCOPE_LOCAL, "_cargs", child_args,     2048);

    the_next_event          = ctx.the_next_event;
    the_exception_event     = ctx.the_exception_event;
    exception_raised        = ctx.exception_raised;

    /*  Load form header fields                                              */
    form = form_init (&form_fxtest3, FALSE);
    data = form-> data;
    context_get    (SCOPE_LOCAL, "_fhead", form, sizeof (FORM_ITEM));
    context_get    (SCOPE_LOCAL, "_fdata", data, form-> data_size);
    context_getsym (SCOPE_LOCAL, "_sel",        &form-> list_values);

    form-> data = data;                 /*  We destroy these fields when we  */
    form-> defn = &form_fxtest3;        /*    reload the form item           */
    session-> form = form;
    return (1);
}

local
_LR_save_context (void)
{
    ctx.the_next_event      = the_next_event;
    ctx.exception_raised    = exception_raised;
    ctx.the_exception_event = the_exception_event;

    /*  Save dialog and programmer context blocks                            */
    context_put (SCOPE_LOCAL, "_ctx", &ctx, sizeof (ctx));
    context_put (SCOPE_LOCAL, "_blk", &cb,  sizeof (cb));
    context_put (SCOPE_LOCAL, "_pargs", parent_args, 2048);
    context_put (SCOPE_LOCAL, "_cargs", child_args,     2048);

    /*  Save form header fields                                              */
    context_put    (SCOPE_LOCAL, "_fhead", session-> form,
                                             sizeof (FORM_ITEM));
    context_put    (SCOPE_LOCAL, "_fdata", session-> form-> data,
                                           session-> form-> data_size);
    context_putsym (SCOPE_LOCAL, "_sel",   session-> form-> list_values);

    form_term (session-> form);
}

local
_LR_show_the_form (Bool after_error)
{
    event_t
        event;
    char
        *proto = "",                    /*  Protocol for hyperlinks          */
        *host = "",                     /*  Server for hyperlinks            */
        *url = NULL;                    /*  Server:port if necessary         */

    /*  If form is being shown normally, format action buttons and call
     *  user exit in before_showing_form ()
     */
    if (!after_error)
      {
        /*  Toggle action buttons to match valid events                      */
        for (event = 0; event < 5; event++)
            if (_LR_action [ctx._LR_state]     [event])
                action_enable  (session-> form, event);
            else
            if (session-> disable_actions == DISABLE_VISIBLE)
                action_disable (session-> form, event);
            else
                action_hide    (session-> form, event);

        before_showing_form ();
      }
    sym_assume_symbol (session-> symbols, "date",
        conv_date_str (date_now (),
            FLAG_D_CENTURY, DATE_YMD_DELIM,
            session-> form-> date_order,
            session-> form-> date_sep, 10));
    sym_assume_symbol (session-> symbols, "time",
        conv_time_str (time_now (), 0, ':', 5));

    /*  Prepare the form 'host' and 'proto' symbols                          */
    if (session-> form-> ssl_protocol)
      {
        proto = "https://";             /*  Switch to SSL                    */
        if (streq (SYMVAL ("SERVER_HTTPS_PORT"), "443"))
            host = SYMVAL ("SERVER_NAME");
        else
          {
            url = xstrcpy (NULL, SYMVAL ("SERVER_NAME"), ":",
                                 SYMVAL ("SERVER_HTTPS_PORT"), NULL);
            host = url;
          }
      }
    else
      {
        proto = "http://";              /*  Switch to non-SSL                */
        if (streq (SYMVAL ("SERVER_HTTP_PORT"), "80"))
            host = SYMVAL ("SERVER_NAME");
        else
          {
            url = xstrcpy (NULL, SYMVAL ("SERVER_NAME"), ":",
                                 SYMVAL ("SERVER_HTTP_PORT"), NULL);
            host = url;
          }
      }

    sym_assume_symbol (session-> symbols, "proto", proto);
    sym_assume_symbol (session-> symbols, "host",     host);
    if (url)
        mem_free (url);

    form_put (session-> form, session-> buffer_, session-> symbols);

    the_next_event = _LR_show_event;
    _LR_save_context ();
}


/*- Standard dialog routines ------------------------------------------------*/

/*  Prepares to call a dialogued program:
 *      Sets session-> program_to_call as specified
 */
local
request_program_call (char *program)
{
    ASSERT (strlen (program) < PRGNAME_MAX);
    strcpy (session-> program_to_call, program);
    _LR_call_wanted = TRUE;             /*  Tell dialog to do the call       */
    before_request_call ();
}

local
get_form_event (void)
{
    the_next_event = session-> form-> event;
}


local
raise_exception (event_t event)
{
    exception_raised = TRUE;
    if (event >= 0)
        the_exception_event = event;
